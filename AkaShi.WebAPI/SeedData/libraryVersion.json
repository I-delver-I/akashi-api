[
  {
    "Id": 1,
    "Name": "13.0.3",
    "DownloadsCount": 85784960,
    "LibraryId": 1,
    "LastUpdateTime": "2023-03-08",
    "UsageContent": "Serialize JSON\nProduct product = new Product();\nproduct.Name = \"Apple\";\nproduct.Expiry = new DateTime(2008, 12, 28);\nproduct.Sizes = new string[] { \"Small\" };\n\nstring json = JsonConvert.SerializeObject(product);\n// {\n//   \"Name\": \"Apple\",\n//   \"Expiry\": \"2008-12-28T00:00:00\",\n//   \"Sizes\": [\n//     \"Small\"\n//   ]\n// }\nDeserialize JSON\nstring json = @\"{\n  'Name': 'Bad Boys',\n  'ReleaseDate': '1995-4-7T00:00:00',\n  'Genres': [\n    'Action',\n    'Comedy'\n  ]\n}\";\n\nMovie m = JsonConvert.DeserializeObject<Movie>(json);\n\nstring name = m.Name;\n// Bad Boys\nLINQ to JSON\nJArray array = new JArray();\narray.Add(\"Manual text\");\narray.Add(new DateTime(2000, 5, 23));\n\nJObject o = new JObject();\no[\"MyArray\"] = array;\n\nstring json = o.ToString();\n// {\n//   \"MyArray\": [\n//     \"Manual text\",\n//     \"2000-05-23T00:00:00\"\n//   ]\n// }",
    "SourceRepositoryURL": "https://github.com/JamesNK/Newtonsoft.Json",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 2,
    "Name": "11.0.2",
    "DownloadsCount": 456940068,
    "LibraryId": 1,
    "LastUpdateTime": "2018-03-24",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/JamesNK/Newtonsoft.Json",
    "LicenseURL": "https://raw.githubusercontent.com/JamesNK/Newtonsoft.Json/master/LICENSE.md",
    "FileExtensionId": 6
  },
  {
    "Id": 3,
    "Name": "9.0.1",
    "DownloadsCount": 609908277,
    "LibraryId": 1,
    "LastUpdateTime": "2016-06-22",
    "UsageContent": "",
    "SourceRepositoryURL": "",
    "LicenseURL": "https://raw.githubusercontent.com/JamesNK/Newtonsoft.Json/master/LICENSE.md",
    "FileExtensionId": 6
  },
  {
    "Id": 4,
    "Name": "7.0.3",
    "DownloadsCount": 4395942,
    "LibraryId": 4,
    "LastUpdateTime": "2023-10-17",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 5,
    "Name": "6.24.0",
    "DownloadsCount": 28078564,
    "LibraryId": 4,
    "LastUpdateTime": "2022-10-13",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 6,
    "Name": "6.8.0",
    "DownloadsCount": 168435584,
    "LibraryId": 4,
    "LastUpdateTime": "2020-10-13",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 7,
    "Name": "12.0.1",
    "DownloadsCount": 36002692,
    "LibraryId": 11,
    "LastUpdateTime": "2023-01-16",
    "UsageContent": "First, configure AutoMapper to know what types you want to map, in the startup of your application:\n\nvar configuration = new MapperConfiguration(cfg => \n{\n    cfg.CreateMap<Foo, FooDto>();\n    cfg.CreateMap<Bar, BarDto>();\n});\n// only during development, validate your mappings; remove it before release\n#if DEBUG\nconfiguration.AssertConfigurationIsValid();\n#endif\n// use DI (http://docs.automapper.org/en/latest/Dependency-injection.html) or create the mapper yourself\nvar mapper = configuration.CreateMapper();\nThen in your application code, execute the mappings:\n\nvar fooDto = mapper.Map<FooDto>(foo);\nvar barDto = mapper.Map<BarDto>(bar);",
    "SourceRepositoryURL": "https://github.com/AutoMapper/AutoMapper",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 8,
    "Name": "10.1.1",
    "DownloadsCount": 108550029,
    "LibraryId": 11,
    "LastUpdateTime": "2020-10-16",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/AutoMapper/AutoMapper",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 9,
    "Name": "9.0.0",
    "DownloadsCount": 83404976,
    "LibraryId": 11,
    "LastUpdateTime": "2019-08-12",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/AutoMapper/AutoMapper",
    "LicenseURL": "https://github.com/AutoMapper/AutoMapper/blob/master/LICENSE.txt",
    "FileExtensionId": 6
  },
  {
    "Id": 10,
    "Name": "8.0.0",
    "DownloadsCount": 5924731,
    "LibraryId": 2,
    "LastUpdateTime": "2023-11-14",
    "UsageContent": "Provides an implementation of the DI interfaces found in the Microsoft.Extensions.DependencyInjection.Abstractions package.\n\nServiceCollection services = new ();\nservices.AddSingleton<IMessageWriter, MessageWriter>();\nusing ServiceProvider provider = services.BuildServiceProvider();\n\n// The code below, following the IoC pattern, is typically only aware of the IMessageWriter interface, not the implementation.\nIMessageWriter messageWriter = provider.GetService<IMessageWriter>()!;\nmessageWriter.Write(\"Hello\");\n\npublic interface IMessageWriter\n{\n    void Write(string message);\n}\n\ninternal class MessageWriter : IMessageWriter\n{\n    public void Write(string message)\n    {\n        Console.WriteLine($\"MessageWriter.Write(message: \\\"{message}\\\")\");\n    }\n}",
    "SourceRepositoryURL": "https://github.com/dotnet/runtime",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 11,
    "Name": "7.0.0",
    "DownloadsCount": 135695429,
    "LibraryId": 2,
    "LastUpdateTime": "2022-11-07",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/dotnet/runtime",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 12,
    "Name": "6.0.0",
    "DownloadsCount": 338597068,
    "LibraryId": 2,
    "LastUpdateTime": "2021-11-08",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/dotnet/runtime",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 13,
    "Name": "8.0.0",
    "DownloadsCount": 1834065,
    "LibraryId": 3,
    "LastUpdateTime": "2023-11-14",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/dotnet/efcore",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 14,
    "Name": "7.0.5",
    "DownloadsCount": 15346288,
    "LibraryId": 3,
    "LastUpdateTime": "2023-04-11",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/dotnet/efcore",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 15,
    "Name": "6.0.7",
    "DownloadsCount": 33042904,
    "LibraryId": 3,
    "LastUpdateTime": "2022-07-12",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/dotnet/efcore",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 16,
    "Name": "8.0.0",
    "DownloadsCount": 197995,
    "LibraryId": 7,
    "LastUpdateTime": "2023-11-14",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/dotnet/runtime",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 17,
    "Name": "7.0.0",
    "DownloadsCount": 26190445,
    "LibraryId": 7,
    "LastUpdateTime": "2022-11-07",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/dotnet/runtime",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 18,
    "Name": "6.0.0",
    "DownloadsCount": 140532334,
    "LibraryId": 7,
    "LastUpdateTime": "2021-11-08",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/dotnet/runtime",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 19,
    "Name": "5.1.2",
    "DownloadsCount": 1932616,
    "LibraryId": 13,
    "LastUpdateTime": "2023-10-26",
    "UsageContent": "Commonly Used Types:\nMicrosoft.Data.SqlClient.SqlConnection\nMicrosoft.Data.SqlClient.SqlException\nMicrosoft.Data.SqlClient.SqlParameter\nMicrosoft.Data.SqlClient.SqlDataReader\nMicrosoft.Data.SqlClient.SqlCommand\nMicrosoft.Data.SqlClient.SqlTransaction\nMicrosoft.Data.SqlClient.SqlParameterCollection\nMicrosoft.Data.SqlClient.SqlClientFactory",
    "SourceRepositoryURL": "https://github.com/dotnet/sqlclient",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 20,
    "Name": "5.0.1",
    "DownloadsCount": 33102569,
    "LibraryId": 13,
    "LastUpdateTime": "2022-10-08",
    "UsageContent": "Commonly Used Types:\nMicrosoft.Data.SqlClient.SqlConnection\nMicrosoft.Data.SqlClient.SqlException\nMicrosoft.Data.SqlClient.SqlParameter\nMicrosoft.Data.SqlClient.SqlDataReader\nMicrosoft.Data.SqlClient.SqlCommand\nMicrosoft.Data.SqlClient.SqlTransaction\nMicrosoft.Data.SqlClient.SqlParameterCollection\nMicrosoft.Data.SqlClient.SqlClientFactory",
    "SourceRepositoryURL": "https://github.com/dotnet/sqlclient",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 21,
    "Name": "2.1.4",
    "DownloadsCount": 80332390,
    "LibraryId": 13,
    "LastUpdateTime": "2021-09-21",
    "UsageContent": "Commonly Used Types:\nMicrosoft.Data.SqlClient.SqlConnection\nMicrosoft.Data.SqlClient.SqlException\nMicrosoft.Data.SqlClient.SqlParameter\nMicrosoft.Data.SqlClient.SqlDataReader\nMicrosoft.Data.SqlClient.SqlCommand\nMicrosoft.Data.SqlClient.SqlTransaction\nMicrosoft.Data.SqlClient.SqlParameterCollection\nMicrosoft.Data.SqlClient.SqlClientFactory",
    "SourceRepositoryURL": "https://github.com/dotnet/sqlclient",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 22,
    "Name": "3.1.1",
    "DownloadsCount": 2799817,
    "LibraryId": 5,
    "LastUpdateTime": "2023-11-10",
    "UsageContent": "Like many other libraries for .NET, Serilog provides diagnostic logging to files, the console, and many other outputs.\n\nusing var log = new LoggerConfiguration()\n    .WriteTo.Console()\n    .WriteTo.File(\"log.txt\")\n    .CreateLogger();\n\nlog.Information(\"Hello, Serilog!\");\nUnlike other logging libraries, Serilog is built from the ground up to record structured event data.\n\nvar position = new { Latitude = 25, Longitude = 134 };\nvar elapsedMs = 34;\n\nlog.Information(\"Processed {@Position} in {Elapsed} ms\", position, elapsedMs);\nSerilog uses message templates, a simple DSL that extends .NET format strings with named as well as positional parameters. Instead of formatting events immediately into text, Serilog captures the values associated with each named parameter.\n\nThe example above records two properties, Position and Elapsed, in the log event. The @ operator in front of Position tells Serilog to serialize the object passed in, rather than convert it using ToString(). Serilog's deep and rich support for structured event data opens up a huge range of diagnostic possibilities not available when using traditional loggers.\n\nRendered into JSON format for example, these properties appear alongside the timestamp, level, and message like:\n\n{\"Position\": {\"Latitude\": 25, \"Longitude\": 134}, \"Elapsed\": 34}\nBack-ends that are capable of recording structured event data make log searches and analysis possible without log parsing or regular expressions.\n\nSupporting structured data doesn't mean giving up text: when Serilog writes events to files or the console, the template and properties are rendered into friendly human-readable text just like a traditional logging library would produce:\n\n09:14:22 [INF] Processed {\"Latitude\": 25, \"Longitude\": 134} in 34 ms.",
    "SourceRepositoryURL": "https://github.com/serilog/serilog",
    "LicenseURL": "https://licenses.nuget.org/Apache-2.0",
    "FileExtensionId": 6
  },
  {
    "Id": 23,
    "Name": "3.0.1",
    "DownloadsCount": 10419507,
    "LibraryId": 5,
    "LastUpdateTime": "2023-06-21",
    "UsageContent": "Like many other libraries for .NET, Serilog provides diagnostic logging to files, the console, and many other outputs.\n\nvar log = new LoggerConfiguration()\n    .WriteTo.Console()\n    .WriteTo.File(\"log.txt\")\n    .CreateLogger();\n\nlog.Information(\"Hello, Serilog!\");\nUnlike other logging libraries, Serilog is built from the ground up to record structured event data.\n\nvar position = new { Latitude = 25, Longitude = 134 };\nvar elapsedMs = 34;\n\nlog.Information(\"Processed {@Position} in {Elapsed} ms\", position, elapsedMs);\nSerilog uses message templates, a simple DSL that extends .NET format strings with named as well as positional parameters. Instead of formatting events immediately into text, Serilog captures the values associated with each named parameter.\n\nThe example above records two properties, Position and Elapsed, in the log event. The @ operator in front of Position tells Serilog to serialize the object passed in, rather than convert it using ToString(). Serilog's deep and rich support for structured event data opens up a huge range of diagnostic possibilities not available when using traditional loggers.\n\nRendered into JSON format for example, these properties appear alongside the timestamp, level, and message like:\n\n{\"Position\": {\"Latitude\": 25, \"Longitude\": 134}, \"Elapsed\": 34}\nBack-ends that are capable of recording structured event data make log searches and analysis possible without log parsing or regular expressions.\n\nSupporting structured data doesn't mean giving up text: when Serilog writes events to files or the console, the template and properties are rendered into friendly human-readable text just like a traditional logging library would produce:\n\n09:14:22 [INF] Processed {\"Latitude\": 25, \"Longitude\": 134} in 34 ms.",
    "SourceRepositoryURL": "https://github.com/serilog/serilog",
    "LicenseURL": "https://licenses.nuget.org/Apache-2.0",
    "FileExtensionId": 6
  },
  {
    "Id": 24,
    "Name": "2.12.0",
    "DownloadsCount": 62397055,
    "LibraryId": 5,
    "LastUpdateTime": "2022-09-13",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/serilog/serilog",
    "LicenseURL": "https://licenses.nuget.org/Apache-2.0",
    "FileExtensionId": 6
  },
  {
    "Id": 25,
    "Name": "6.12.0",
    "DownloadsCount": 8740195,
    "LibraryId": 14,
    "LastUpdateTime": "2023-10-26",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/fluentassertions/fluentassertions",
    "LicenseURL": "https://licenses.nuget.org/Apache-2.0",
    "FileExtensionId": 6
  },
  {
    "Id": 26,
    "Name": "6.7.0",
    "DownloadsCount": 26902239,
    "LibraryId": 14,
    "LastUpdateTime": "2022-05-18",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/fluentassertions/fluentassertions",
    "LicenseURL": "https://licenses.nuget.org/Apache-2.0",
    "FileExtensionId": 6
  },
  {
    "Id": 27,
    "Name": "5.10.3",
    "DownloadsCount": 76595953,
    "LibraryId": 14,
    "LastUpdateTime": "2020-03-21",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/fluentassertions/fluentassertions",
    "LicenseURL": "https://licenses.nuget.org/Apache-2.0",
    "FileExtensionId": 6
  },
  {
    "Id": 28,
    "Name": "1.36.0",
    "DownloadsCount": 4478813,
    "LibraryId": 6,
    "LastUpdateTime": "2023-11-10",
    "UsageContent": "Examples\nNOTE: Samples in this file apply only to packages that follow Azure SDK Design Guidelines. Names of such packages usually start with Azure.\n\nConfiguring Service Clients Using ClientOptions\nAzure SDK client libraries typically expose one or more service client types that are the main starting points for calling corresponding Azure services. You can easily find these client types as their names end with the word Client. For example, BlockBlobClient can be used to call blob storage service, and KeyClient can be used to access Key Vault service cryptographic keys.\n\nThese client types can be instantiated by calling a simple constructor, or its overload that takes various configuration options. These options are passed as a parameter that extends ClientOptions class exposed by Azure.Core. Various service specific options are usually added to its subclasses, but a set of SDK-wide options are available directly on ClientOptions.\n\nSecretClientOptions options = new SecretClientOptions()\n{\n    Retry =\n    {\n        Delay = TimeSpan.FromSeconds(2),\n        MaxRetries = 10,\n        Mode = RetryMode.Fixed\n    },\n    Diagnostics =\n    {\n        IsLoggingContentEnabled = true,\n        ApplicationId = \"myApplicationId\"\n    }\n};\n\nSecretClient client = new SecretClient(new Uri(\"http://example.com\"), new DefaultAzureCredential(), options);\nMore on client configuration in client configuration samples.\n\nAccessing HTTP Response Details Using Response<T>\nService clients have methods that can be used to call Azure services. We refer to these client methods service methods. Service methods return a shared Azure.Core type Response<T> (in rare cases its non-generic sibling, a raw Response). This type provides access to both the deserialized result of the service call, and to the details of the HTTP response returned from the server.\n\n// create a client\nvar client = new SecretClient(new Uri(\"http://example.com\"), new DefaultAzureCredential());\n\n// call a service method, which returns Response<T>\nResponse<KeyVaultSecret> response = await client.GetSecretAsync(\"SecretName\");\n\n// Response<T> has two main accessors.\n// Value property for accessing the deserialized result of the call\nKeyVaultSecret secret = response.Value;\n\n// .. and GetRawResponse method for accessing all the details of the HTTP response\nResponse http = response.GetRawResponse();\n\n// for example, you can access HTTP status\nint status = http.Status;\n\n// or the headers\nforeach (HttpHeader header in http.Headers)\n{\n    Console.WriteLine($\"{header.Name} {header.Value}\");\n}\nMore on response types in response samples.\n\nSetting up console logging\nTo create an Azure SDK log listener that outputs messages to console use AzureEventSourceListener.CreateConsoleLogger method.\n\n// Setup a listener to monitor logged events.\nusing AzureEventSourceListener listener = AzureEventSourceListener.CreateConsoleLogger();\nMore on logging in diagnostics samples.\n\nReporting Errors RequestFailedException\nWhen a service call fails Azure.RequestFailedException would get thrown. The exception type provides a Status property with an HTTP status code and an ErrorCode property with a service-specific error code.\n\ntry\n{\n    KeyVaultSecret secret = client.GetSecret(\"NonexistentSecret\");\n}\n// handle exception with status code 404\ncatch (RequestFailedException e) when (e.Status == 404)\n{\n    // handle not found error\n    Console.WriteLine(\"ErrorCode \" + e.ErrorCode);\n}\nMore on handling responses in response samples.\n\nConsuming Service Methods Returning AsyncPageable<T>\nIf a service call returns multiple values in pages, it would return Pageable<T>/AsyncPageable<T> as a result. You can iterate over AsyncPageable directly or in pages.\n\n// call a service method, which returns AsyncPageable<T>\nAsyncPageable<SecretProperties> allSecretProperties = client.GetPropertiesOfSecretsAsync();\n\nawait foreach (SecretProperties secretProperties in allSecretProperties)\n{\n    Console.WriteLine(secretProperties.Name);\n}\nFor more information on paged responses, see Pagination with the Azure SDK for .NET.\n\nConsuming Long-Running Operations Using Operation<T>\nSome operations take long time to complete and require polling for their status. Methods starting long-running operations return *Operation<T> types.\n\nThe WaitForCompletionAsync method is an easy way to wait for operation completion and get the resulting value.\n\n// create a client\nSecretClient client = new SecretClient(new Uri(\"http://example.com\"), new DefaultAzureCredential());\n\n// Start the operation\nDeleteSecretOperation operation = await client.StartDeleteSecretAsync(\"SecretName\");\n\nResponse<DeletedSecret> response = await operation.WaitForCompletionAsync();\nDeletedSecret value = response.Value;\n\nConsole.WriteLine(value.Name);\nConsole.WriteLine(value.ScheduledPurgeDate);\nMore on long-running operations in long-running operation samples.\n\nCustomizing Requests Using RequestContext\nBesides general configuration of service clients through ClientOptions, it is possible to customize the requests sent by service clients using protocol methods or convenience APIs that expose RequestContext as a parameter.\n\nvar context = new RequestContext();\ncontext.AddClassifier(404, isError: false);\n\nResponse response = await client.GetPetAsync(\"pet1\", context);\nMore on request customization in RequestContext samples.\n\nMocking\nOne of the most important cross-cutting features of our new client libraries using Azure.Core is that they are designed for mocking. Mocking is enabled by:\n\nproviding a protected parameterless constructor on client types.\nmaking service methods virtual.\nproviding APIs for constructing model types returned from virtual service methods. To find these factory methods look for types with the ModelFactory suffix, e.g. SecretModelFactory.\nFor example, the ConfigurationClient.Get method can be mocked (with Moq) as follows:\n\n// Create a mock response\nvar mockResponse = new Mock<Response>();\n\n// Create a mock value\nvar mockValue = SecretModelFactory.KeyVaultSecret(\n    SecretModelFactory.SecretProperties(new Uri(\"http://example.com\"))\n);\n\n// Create a client mock\nvar mock = new Mock<SecretClient>();\n\n// Setup client method\nmock.Setup(c => c.GetSecret(\"Name\", null, default))\n    .Returns(Response.FromValue(mockValue, mockResponse.Object));\n\n// Use the client mock\nSecretClient client = mock.Object;\nKeyVaultSecret secret = client.GetSecret(\"Name\");",
    "SourceRepositoryURL": "https://github.com/Azure/azure-sdk-for-net",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 29,
    "Name": "1.25.0",
    "DownloadsCount": 101963009,
    "LibraryId": 6,
    "LastUpdateTime": "2022-06-30",
    "UsageContent": "Examples\nNOTE: Samples in this file apply only to packages that follow Azure SDK Design Guidelines. Names of such packages usually start with Azure.\n\nConfiguring Service Clients Using ClientOptions\nAzure SDK client libraries typically expose one or more service client types that are the main starting points for calling corresponding Azure services. You can easily find these client types as their names end with the word Client. For example, BlockBlobClient can be used to call blob storage service, and KeyClient can be used to access Key Vault service cryptographic keys.\n\nThese client types can be instantiated by calling a simple constructor, or its overload that takes various configuration options. These options are passed as a parameter that extends ClientOptions class exposed by Azure.Core. Various service specific options are usually added to its subclasses, but a set of SDK-wide options are available directly on ClientOptions.\n\nSecretClientOptions options = new SecretClientOptions()\n{\n    Retry =\n    {\n        Delay = TimeSpan.FromSeconds(2),\n        MaxRetries = 10,\n        Mode = RetryMode.Fixed\n    },\n    Diagnostics =\n    {\n        IsLoggingContentEnabled = true,\n        ApplicationId = \"myApplicationId\"\n    }\n};\n\nSecretClient client = new SecretClient(new Uri(\"http://example.com\"), new DefaultAzureCredential(), options);\nMore on client configuration in client configuration samples\n\nAccessing HTTP Response Details Using Response<T>\nService clients have methods that can be used to call Azure services. We refer to these client methods service methods. Service methods return a shared Azure.Core type Response<T> (in rare cases its non-generic sibling, a raw Response). This type provides access to both the deserialized result of the service call, and to the details of the HTTP response returned from the server.\n\n// create a client\nvar client = new SecretClient(new Uri(\"http://example.com\"), new DefaultAzureCredential());\n\n// call a service method, which returns Response<T>\nResponse<KeyVaultSecret> response = await client.GetSecretAsync(\"SecretName\");\n\n// Response<T> has two main accessors.\n// Value property for accessing the deserialized result of the call\nKeyVaultSecret secret = response.Value;\n\n// .. and GetRawResponse method for accessing all the details of the HTTP response\nResponse http = response.GetRawResponse();\n\n// for example, you can access HTTP status\nint status = http.Status;\n\n// or the headers\nforeach (HttpHeader header in http.Headers)\n{\n    Console.WriteLine($\"{header.Name} {header.Value}\");\n}\nMore on response types in response samples\n\nSetting up console logging\nTo create an Azure SDK log listener that outputs messages to console use AzureEventSourceListener.CreateConsoleLogger method.\n\n// Setup a listener to monitor logged events.\nusing AzureEventSourceListener listener = AzureEventSourceListener.CreateConsoleLogger();\nMore on logging in diagnostics samples\n\nReporting Errors RequestFailedException\nWhen a service call fails Azure.RequestFailedException would get thrown. The exception type provides a Status property with an HTTP status code and an ErrorCode property with a service-specific error code.\n\ntry\n{\n    KeyVaultSecret secret = client.GetSecret(\"NonexistentSecret\");\n}\n// handle exception with status code 404\ncatch (RequestFailedException e) when (e.Status == 404)\n{\n    // handle not found error\n    Console.WriteLine(\"ErrorCode \" + e.ErrorCode);\n}\nMore on handling responses in response samples\n\nConsuming Service Methods Returning AsyncPageable<T>\nIf a service call returns multiple values in pages, it would return Pageable<T>/AsyncPageable<T> as a result. You can iterate over AsyncPageable directly or in pages.\n\n// call a service method, which returns AsyncPageable<T>\nAsyncPageable<SecretProperties> allSecretProperties = client.GetPropertiesOfSecretsAsync();\n\nawait foreach (SecretProperties secretProperties in allSecretProperties)\n{\n    Console.WriteLine(secretProperties.Name);\n}\nFor more information on paged responses, see Pagination with the Azure SDK for .NET.\n\nConsuming Long-Running Operations Using Operation<T>\nSome operations take long time to complete and require polling for their status. Methods starting long-running operations return *Operation<T> types.\n\nThe WaitForCompletionAsync method is an easy way to wait for operation completion and get the resulting value.\n\n// create a client\nSecretClient client = new SecretClient(new Uri(\"http://example.com\"), new DefaultAzureCredential());\n\n// Start the operation\nDeleteSecretOperation operation = await client.StartDeleteSecretAsync(\"SecretName\");\n\nResponse<DeletedSecret> response = await operation.WaitForCompletionAsync();\nDeletedSecret value = response.Value;\n\nConsole.WriteLine(value.Name);\nConsole.WriteLine(value.ScheduledPurgeDate);\nMore on long-running operations in long-running operation samples\n\nCustomzing Request Using RequestContext\nBesides general configuration of service clients through ClientOptions, it is possible to customize the requests sent by service clients using protocol methods or convenience APIs that expose RequestContext as a parameter.\n\nvar context = new RequestContext();\ncontext.AddClassifier(404, isError: false);\n\nResponse response = await client.GetPetAsync(\"pet1\", context);\nMore on request customization in RequestContext samples\n\nMocking\nOne of the most important cross-cutting features of our new client libraries using Azure.Core is that they are designed for mocking. Mocking is enabled by:\n\nproviding a protected parameterless constructor on client types.\nmaking service methods virtual.\nproviding APIs for constructing model types returned from virtual service methods. To find these factory methods look for types with the ModelFactory suffix, e.g. SecretModelFactory.\nFor example, the ConfigurationClient.Get method can be mocked (with Moq) as follows:\n\n// Create a mock response\nvar mockResponse = new Mock<Response>();\n\n// Create a mock value\nvar mockValue = SecretModelFactory.KeyVaultSecret(\n    SecretModelFactory.SecretProperties(new Uri(\"http://example.com\"))\n);\n\n// Create a client mock\nvar mock = new Mock<SecretClient>();\n\n// Setup client method\nmock.Setup(c => c.GetSecret(\"Name\", null, default))\n    .Returns(Response.FromValue(mockValue, mockResponse.Object));\n\n// Use the client mock\nSecretClient client = mock.Object;\nKeyVaultSecret secret = client.GetSecret(\"Name\");",
    "SourceRepositoryURL": "https://github.com/Azure/azure-sdk-for-net",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 30,
    "Name": "1.6.0",
    "DownloadsCount": 108675594,
    "LibraryId": 6,
    "LastUpdateTime": "2020-10-28",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/Azure/azure-sdk-for-net",
    "LicenseURL": "https://licenses.nuget.org/MIT",
    "FileExtensionId": 6
  },
  {
    "Id": 31,
    "Name": "5.1.1",
    "DownloadsCount": 57854685,
    "LibraryId": 8,
    "LastUpdateTime": "2022-12-30",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/castleproject/Core",
    "LicenseURL": "https://licenses.nuget.org/Apache-2.0",
    "FileExtensionId": 6
  },
  {
    "Id": 32,
    "Name": "4.4.0",
    "DownloadsCount": 263104443,
    "LibraryId": 8,
    "LastUpdateTime": "2019-04-05",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/castleproject/Core",
    "LicenseURL": "https://www.apache.org/licenses/LICENSE-2.0.html",
    "FileExtensionId": 6
  },
  {
    "Id": 33,
    "Name": "4.0.0",
    "DownloadsCount": 22939604,
    "LibraryId": 8,
    "LastUpdateTime": "2017-01-24",
    "UsageContent": "",
    "SourceRepositoryURL": "",
    "LicenseURL": "https://www.apache.org/licenses/LICENSE-2.0.html",
    "FileExtensionId": 6
  },
  {
    "Id": 34,
    "Name": "3.7.300",
    "DownloadsCount": 641241,
    "LibraryId": 9,
    "LastUpdateTime": "2023-11-10",
    "UsageContent": "",
    "SourceRepositoryURL": "",
    "LicenseURL": "https://licenses.nuget.org/Apache-2.0",
    "FileExtensionId": 6
  },
  {
    "Id": 35,
    "Name": "3.7.204",
    "DownloadsCount": 496049,
    "LibraryId": 9,
    "LastUpdateTime": "2023-10-07",
    "UsageContent": "",
    "SourceRepositoryURL": "",
    "LicenseURL": "https://licenses.nuget.org/Apache-2.0",
    "FileExtensionId": 6
  },
  {
    "Id": 36,
    "Name": "3.7.100",
    "DownloadsCount": 14827784,
    "LibraryId": 9,
    "LastUpdateTime": "2022-11-09",
    "UsageContent": "",
    "SourceRepositoryURL": "",
    "LicenseURL": "http://aws.amazon.com/apache2.0/",
    "FileExtensionId": 6
  },
  {
    "Id": 37,
    "Name": "4.18.4",
    "DownloadsCount": 44200281,
    "LibraryId": 10,
    "LastUpdateTime": "2022-12-30",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/moq/moq4",
    "LicenseURL": "https://raw.githubusercontent.com/moq/moq4/main/License.txt",
    "FileExtensionId": 6
  },
  {
    "Id": 38,
    "Name": "4.16.1",
    "DownloadsCount": 88210016,
    "LibraryId": 10,
    "LastUpdateTime": "2021-02-23",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/moq/moq4",
    "LicenseURL": "https://raw.githubusercontent.com/moq/moq4/master/License.txt",
    "FileExtensionId": 6
  },
  {
    "Id": 39,
    "Name": "4.13.1",
    "DownloadsCount": 44266355,
    "LibraryId": 10,
    "LastUpdateTime": "2019-10-19",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/moq/moq4",
    "LicenseURL": "https://raw.githubusercontent.com/moq/moq4/master/License.txt",
    "FileExtensionId": 6
  },
  {
    "Id": 40,
    "Name": "8.2.0",
    "DownloadsCount": 2305117,
    "LibraryId": 12,
    "LastUpdateTime": "2023-11-14",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/App-vNext/Polly",
    "LicenseURL": "https://licenses.nuget.org/BSD-3-Clause",
    "FileExtensionId": 6
  },
  {
    "Id": 41,
    "Name": "7.2.3",
    "DownloadsCount": 108665588,
    "LibraryId": 12,
    "LastUpdateTime": "2022-01-17",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/App-vNext/Polly.git",
    "LicenseURL": "https://licenses.nuget.org/BSD-3-Clause",
    "FileExtensionId": 6
  },
  {
    "Id": 42,
    "Name": "6.0.1",
    "DownloadsCount": 21609357,
    "LibraryId": 12,
    "LastUpdateTime": "2018-05-06",
    "UsageContent": "",
    "SourceRepositoryURL": "",
    "LicenseURL": "https://raw.github.com/App-vNext/Polly/master/LICENSE.txt",
    "FileExtensionId": 6
  },
  {
    "Id": 43,
    "Name": "11.7.1",
    "DownloadsCount": 4617920,
    "LibraryId": 15,
    "LastUpdateTime": "2023-08-12",
    "UsageContent": "With FluentValidation, you can define a class that inherits from AbstractValidator which contains the rules for a particular class. The example below shows how you could define rules for a Customer class, and then how to execute the validator.\n\nusing FluentValidation;\n\npublic class CustomerValidator: AbstractValidator<Customer> {\n  public CustomerValidator() {\n    RuleFor(x => x.Surname).NotEmpty();\n    RuleFor(x => x.Forename).NotEmpty().WithMessage(\"Please specify a first name\");\n    RuleFor(x => x.Discount).NotEqual(0).When(x => x.HasDiscount);\n    RuleFor(x => x.Address).Length(20, 250);\n    RuleFor(x => x.Postcode).Must(BeAValidPostcode).WithMessage(\"Please specify a valid postcode\");\n  }\n\n  private bool BeAValidPostcode(string postcode) {\n    // custom postcode validating logic goes here\n  }\n}\n\nvar customer = new Customer();\nvar validator = new CustomerValidator();\n\n// Execute the validator.\nValidationResult results = validator.Validate(customer);\n\n// Inspect any validation failures.\nbool success = results.IsValid;\nList<ValidationFailure> failures = results.Errors;",
    "SourceRepositoryURL": "https://github.com/JeremySkinner/fluentvalidation",
    "LicenseURL": "https://licenses.nuget.org/Apache-2.0",
    "FileExtensionId": 6
  },
  {
    "Id": 44,
    "Name": "10.3.6",
    "DownloadsCount": 19729520,
    "LibraryId": 15,
    "LastUpdateTime": "2021-12-13",
    "UsageContent": "Example\nWith FluentValidation, you can define a class that inherits from AbstractValidator which contains the rules for a particular class. The example below shows how you could define rules for a Customer class, and then how to execute the validator.\n\nusing FluentValidation;\n\npublic class CustomerValidator: AbstractValidator<Customer> {\n  public CustomerValidator() {\n    RuleFor(x => x.Surname).NotEmpty();\n    RuleFor(x => x.Forename).NotEmpty().WithMessage(\"Please specify a first name\");\n    RuleFor(x => x.Discount).NotEqual(0).When(x => x.HasDiscount);\n    RuleFor(x => x.Address).Length(20, 250);\n    RuleFor(x => x.Postcode).Must(BeAValidPostcode).WithMessage(\"Please specify a valid postcode\");\n  }\n\n  private bool BeAValidPostcode(string postcode) {\n    // custom postcode validating logic goes here\n  }\n}\n\nvar customer = new Customer();\nvar validator = new CustomerValidator();\n\n// Execute the validator.\nValidationResult results = validator.Validate(customer);\n\n// Inspect any validation failures.\nbool success = results.IsValid;\nList<ValidationFailure> failures = results.Errors;",
    "SourceRepositoryURL": "https://github.com/JeremySkinner/fluentvalidation",
    "LicenseURL": "https://licenses.nuget.org/Apache-2.0",
    "FileExtensionId": 6
  },
  {
    "Id": 45,
    "Name": "9.3.0",
    "DownloadsCount": 11676192,
    "LibraryId": 15,
    "LastUpdateTime": "2020-11-10",
    "UsageContent": "",
    "SourceRepositoryURL": "https://github.com/JeremySkinner/fluentvalidation",
    "LicenseURL": "https://licenses.nuget.org/Apache-2.0",
    "FileExtensionId": 6
  }
]